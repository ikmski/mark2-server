// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mark2.proto

/*
Package mark2 is a generated protocol buffer package.

It is generated from these files:
	mark2.proto

It has these top-level messages:
	AccessToken
	UserInfo
	UserInfoList
	RoomInfo
	RoomInfoList
	Message
	MessageList
	LoginRequest
	CreateRoomRequest
	JoinRoomRequest
	MatchRequest
	MessageRequest
	Result
	LoginResult
	UserInfoListResult
	RoomInfoListResult
	UserInfoResult
	RoomInfoResult
*/
package mark2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 結果コード
type ResultCodes int32

const (
	ResultCodes_NG ResultCodes = 0
	ResultCodes_OK ResultCodes = 1
)

var ResultCodes_name = map[int32]string{
	0: "NG",
	1: "OK",
}
var ResultCodes_value = map[string]int32{
	"NG": 0,
	"OK": 1,
}

func (x ResultCodes) String() string {
	return proto.EnumName(ResultCodes_name, int32(x))
}
func (ResultCodes) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// ユーザステータス
type UserStatus int32

const (
	UserStatus_Logout    UserStatus = 0
	UserStatus_Login     UserStatus = 1
	UserStatus_WaitMatch UserStatus = 2
	UserStatus_Matching  UserStatus = 3
)

var UserStatus_name = map[int32]string{
	0: "Logout",
	1: "Login",
	2: "WaitMatch",
	3: "Matching",
}
var UserStatus_value = map[string]int32{
	"Logout":    0,
	"Login":     1,
	"WaitMatch": 2,
	"Matching":  3,
}

func (x UserStatus) String() string {
	return proto.EnumName(UserStatus_name, int32(x))
}
func (UserStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// ルームステータス
type RoomStatus int32

const (
	RoomStatus_CLOSED RoomStatus = 0
	RoomStatus_OPEN   RoomStatus = 1
)

var RoomStatus_name = map[int32]string{
	0: "CLOSED",
	1: "OPEN",
}
var RoomStatus_value = map[string]int32{
	"CLOSED": 0,
	"OPEN":   1,
}

func (x RoomStatus) String() string {
	return proto.EnumName(RoomStatus_name, int32(x))
}
func (RoomStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// メッセージタイプ
type MessageType int32

const (
	MessageType_NONE      MessageType = 0
	MessageType_OWN       MessageType = 1
	MessageType_ROOM      MessageType = 2
	MessageType_BROADCAST MessageType = 3
)

var MessageType_name = map[int32]string{
	0: "NONE",
	1: "OWN",
	2: "ROOM",
	3: "BROADCAST",
}
var MessageType_value = map[string]int32{
	"NONE":      0,
	"OWN":       1,
	"ROOM":      2,
	"BROADCAST": 3,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}
func (MessageType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// アクセストークン
type AccessToken struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *AccessToken) Reset()                    { *m = AccessToken{} }
func (m *AccessToken) String() string            { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()               {}
func (*AccessToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AccessToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// ユーザ情報
type UserInfo struct {
	GroupId uint32     `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	Id      uint32     `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Status  UserStatus `protobuf:"varint,3,opt,name=status,enum=mark2.UserStatus" json:"status,omitempty"`
}

func (m *UserInfo) Reset()                    { *m = UserInfo{} }
func (m *UserInfo) String() string            { return proto.CompactTextString(m) }
func (*UserInfo) ProtoMessage()               {}
func (*UserInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *UserInfo) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UserInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UserInfo) GetStatus() UserStatus {
	if m != nil {
		return m.Status
	}
	return UserStatus_Logout
}

// ユーザ情報リスト
type UserInfoList struct {
	List []*UserInfo `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *UserInfoList) Reset()                    { *m = UserInfoList{} }
func (m *UserInfoList) String() string            { return proto.CompactTextString(m) }
func (*UserInfoList) ProtoMessage()               {}
func (*UserInfoList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UserInfoList) GetList() []*UserInfo {
	if m != nil {
		return m.List
	}
	return nil
}

// ルーム情報
type RoomInfo struct {
	GroupId    uint32     `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	Id         uint32     `protobuf:"varint,2,opt,name=id" json:"id,omitempty"`
	Capacity   uint32     `protobuf:"varint,3,opt,name=capacity" json:"capacity,omitempty"`
	Status     RoomStatus `protobuf:"varint,4,opt,name=status,enum=mark2.RoomStatus" json:"status,omitempty"`
	UserIdList []uint32   `protobuf:"varint,5,rep,packed,name=user_id_list,json=userIdList" json:"user_id_list,omitempty"`
}

func (m *RoomInfo) Reset()                    { *m = RoomInfo{} }
func (m *RoomInfo) String() string            { return proto.CompactTextString(m) }
func (*RoomInfo) ProtoMessage()               {}
func (*RoomInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RoomInfo) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *RoomInfo) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *RoomInfo) GetCapacity() uint32 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *RoomInfo) GetStatus() RoomStatus {
	if m != nil {
		return m.Status
	}
	return RoomStatus_CLOSED
}

func (m *RoomInfo) GetUserIdList() []uint32 {
	if m != nil {
		return m.UserIdList
	}
	return nil
}

// ルーム情報リスト
type RoomInfoList struct {
	List []*RoomInfo `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *RoomInfoList) Reset()                    { *m = RoomInfoList{} }
func (m *RoomInfoList) String() string            { return proto.CompactTextString(m) }
func (*RoomInfoList) ProtoMessage()               {}
func (*RoomInfoList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *RoomInfoList) GetList() []*RoomInfo {
	if m != nil {
		return m.List
	}
	return nil
}

// メッセージ
type Message struct {
	Id         uint32      `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Type       MessageType `protobuf:"varint,2,opt,name=type,enum=mark2.MessageType" json:"type,omitempty"`
	FromUserId uint32      `protobuf:"varint,3,opt,name=from_user_id,json=fromUserId" json:"from_user_id,omitempty"`
	Content    string      `protobuf:"bytes,4,opt,name=content" json:"content,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Message) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Message) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_NONE
}

func (m *Message) GetFromUserId() uint32 {
	if m != nil {
		return m.FromUserId
	}
	return 0
}

func (m *Message) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// メッセージリスト
type MessageList struct {
	List []*Message `protobuf:"bytes,1,rep,name=list" json:"list,omitempty"`
}

func (m *MessageList) Reset()                    { *m = MessageList{} }
func (m *MessageList) String() string            { return proto.CompactTextString(m) }
func (*MessageList) ProtoMessage()               {}
func (*MessageList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *MessageList) GetList() []*Message {
	if m != nil {
		return m.List
	}
	return nil
}

// ログインリクエスト
type LoginRequest struct {
	GroupId   uint32 `protobuf:"varint,1,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	UniqueKey string `protobuf:"bytes,2,opt,name=unique_key,json=uniqueKey" json:"unique_key,omitempty"`
}

func (m *LoginRequest) Reset()                    { *m = LoginRequest{} }
func (m *LoginRequest) String() string            { return proto.CompactTextString(m) }
func (*LoginRequest) ProtoMessage()               {}
func (*LoginRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LoginRequest) GetGroupId() uint32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *LoginRequest) GetUniqueKey() string {
	if m != nil {
		return m.UniqueKey
	}
	return ""
}

// ルーム作成リクエスト
type CreateRoomRequest struct {
	Token    *AccessToken `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Capacity uint32       `protobuf:"varint,2,opt,name=capacity" json:"capacity,omitempty"`
}

func (m *CreateRoomRequest) Reset()                    { *m = CreateRoomRequest{} }
func (m *CreateRoomRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateRoomRequest) ProtoMessage()               {}
func (*CreateRoomRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateRoomRequest) GetToken() *AccessToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *CreateRoomRequest) GetCapacity() uint32 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

// ルーム参加リクエスト
type JoinRoomRequest struct {
	Token  *AccessToken `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	RoomId uint32       `protobuf:"varint,2,opt,name=room_id,json=roomId" json:"room_id,omitempty"`
}

func (m *JoinRoomRequest) Reset()                    { *m = JoinRoomRequest{} }
func (m *JoinRoomRequest) String() string            { return proto.CompactTextString(m) }
func (*JoinRoomRequest) ProtoMessage()               {}
func (*JoinRoomRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *JoinRoomRequest) GetToken() *AccessToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *JoinRoomRequest) GetRoomId() uint32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

// マッチリクエスト
type MatchRequest struct {
	Token *AccessToken `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Key   string       `protobuf:"bytes,2,opt,name=key" json:"key,omitempty"`
}

func (m *MatchRequest) Reset()                    { *m = MatchRequest{} }
func (m *MatchRequest) String() string            { return proto.CompactTextString(m) }
func (*MatchRequest) ProtoMessage()               {}
func (*MatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *MatchRequest) GetToken() *AccessToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *MatchRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

// メッセージリクエスト
type MessageRequest struct {
	Token   *AccessToken `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	Type    MessageType  `protobuf:"varint,2,opt,name=type,enum=mark2.MessageType" json:"type,omitempty"`
	Content string       `protobuf:"bytes,3,opt,name=content" json:"content,omitempty"`
}

func (m *MessageRequest) Reset()                    { *m = MessageRequest{} }
func (m *MessageRequest) String() string            { return proto.CompactTextString(m) }
func (*MessageRequest) ProtoMessage()               {}
func (*MessageRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *MessageRequest) GetToken() *AccessToken {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *MessageRequest) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_NONE
}

func (m *MessageRequest) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

// 結果一般
type Result struct {
	Code    ResultCodes `protobuf:"varint,1,opt,name=code,enum=mark2.ResultCodes" json:"code,omitempty"`
	Message string      `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Result) GetCode() ResultCodes {
	if m != nil {
		return m.Code
	}
	return ResultCodes_NG
}

func (m *Result) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// ログイン結果
type LoginResult struct {
	Result      *Result      `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	AccessToken *AccessToken `protobuf:"bytes,2,opt,name=access_token,json=accessToken" json:"access_token,omitempty"`
}

func (m *LoginResult) Reset()                    { *m = LoginResult{} }
func (m *LoginResult) String() string            { return proto.CompactTextString(m) }
func (*LoginResult) ProtoMessage()               {}
func (*LoginResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *LoginResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *LoginResult) GetAccessToken() *AccessToken {
	if m != nil {
		return m.AccessToken
	}
	return nil
}

// ユーザ情報リスト結果
type UserInfoListResult struct {
	Result       *Result       `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	UserInfoList *UserInfoList `protobuf:"bytes,2,opt,name=user_info_list,json=userInfoList" json:"user_info_list,omitempty"`
}

func (m *UserInfoListResult) Reset()                    { *m = UserInfoListResult{} }
func (m *UserInfoListResult) String() string            { return proto.CompactTextString(m) }
func (*UserInfoListResult) ProtoMessage()               {}
func (*UserInfoListResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *UserInfoListResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *UserInfoListResult) GetUserInfoList() *UserInfoList {
	if m != nil {
		return m.UserInfoList
	}
	return nil
}

// ルーム情報リスト結果
type RoomInfoListResult struct {
	Result       *Result       `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	RoomInfoList *RoomInfoList `protobuf:"bytes,2,opt,name=room_info_list,json=roomInfoList" json:"room_info_list,omitempty"`
}

func (m *RoomInfoListResult) Reset()                    { *m = RoomInfoListResult{} }
func (m *RoomInfoListResult) String() string            { return proto.CompactTextString(m) }
func (*RoomInfoListResult) ProtoMessage()               {}
func (*RoomInfoListResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RoomInfoListResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RoomInfoListResult) GetRoomInfoList() *RoomInfoList {
	if m != nil {
		return m.RoomInfoList
	}
	return nil
}

// ユーザ情報結果
type UserInfoResult struct {
	Result   *Result   `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	UserInfo *UserInfo `protobuf:"bytes,2,opt,name=user_info,json=userInfo" json:"user_info,omitempty"`
}

func (m *UserInfoResult) Reset()                    { *m = UserInfoResult{} }
func (m *UserInfoResult) String() string            { return proto.CompactTextString(m) }
func (*UserInfoResult) ProtoMessage()               {}
func (*UserInfoResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *UserInfoResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *UserInfoResult) GetUserInfo() *UserInfo {
	if m != nil {
		return m.UserInfo
	}
	return nil
}

// ルーム情報結果
type RoomInfoResult struct {
	Result   *Result   `protobuf:"bytes,1,opt,name=result" json:"result,omitempty"`
	RoomInfo *RoomInfo `protobuf:"bytes,2,opt,name=room_info,json=roomInfo" json:"room_info,omitempty"`
}

func (m *RoomInfoResult) Reset()                    { *m = RoomInfoResult{} }
func (m *RoomInfoResult) String() string            { return proto.CompactTextString(m) }
func (*RoomInfoResult) ProtoMessage()               {}
func (*RoomInfoResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *RoomInfoResult) GetResult() *Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *RoomInfoResult) GetRoomInfo() *RoomInfo {
	if m != nil {
		return m.RoomInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*AccessToken)(nil), "mark2.AccessToken")
	proto.RegisterType((*UserInfo)(nil), "mark2.UserInfo")
	proto.RegisterType((*UserInfoList)(nil), "mark2.UserInfoList")
	proto.RegisterType((*RoomInfo)(nil), "mark2.RoomInfo")
	proto.RegisterType((*RoomInfoList)(nil), "mark2.RoomInfoList")
	proto.RegisterType((*Message)(nil), "mark2.Message")
	proto.RegisterType((*MessageList)(nil), "mark2.MessageList")
	proto.RegisterType((*LoginRequest)(nil), "mark2.LoginRequest")
	proto.RegisterType((*CreateRoomRequest)(nil), "mark2.CreateRoomRequest")
	proto.RegisterType((*JoinRoomRequest)(nil), "mark2.JoinRoomRequest")
	proto.RegisterType((*MatchRequest)(nil), "mark2.MatchRequest")
	proto.RegisterType((*MessageRequest)(nil), "mark2.MessageRequest")
	proto.RegisterType((*Result)(nil), "mark2.Result")
	proto.RegisterType((*LoginResult)(nil), "mark2.LoginResult")
	proto.RegisterType((*UserInfoListResult)(nil), "mark2.UserInfoListResult")
	proto.RegisterType((*RoomInfoListResult)(nil), "mark2.RoomInfoListResult")
	proto.RegisterType((*UserInfoResult)(nil), "mark2.UserInfoResult")
	proto.RegisterType((*RoomInfoResult)(nil), "mark2.RoomInfoResult")
	proto.RegisterEnum("mark2.ResultCodes", ResultCodes_name, ResultCodes_value)
	proto.RegisterEnum("mark2.UserStatus", UserStatus_name, UserStatus_value)
	proto.RegisterEnum("mark2.RoomStatus", RoomStatus_name, RoomStatus_value)
	proto.RegisterEnum("mark2.MessageType", MessageType_name, MessageType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MessageService service

type MessageServiceClient interface {
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResult, error)
	Logout(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*Result, error)
	GetUserInfoList(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserInfoListResult, error)
	GetRoomInfoList(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*RoomInfoListResult, error)
	GetOwnUserInfo(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserInfoResult, error)
	GetOwnRoomInfo(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*RoomInfoResult, error)
	CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*RoomInfoResult, error)
	JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*RoomInfoResult, error)
	MatchRandom(ctx context.Context, in *MatchRequest, opts ...grpc.CallOption) (*RoomInfoResult, error)
	ExitRoom(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*Result, error)
	SendMessage(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*Result, error)
	SendStream(ctx context.Context, opts ...grpc.CallOption) (MessageService_SendStreamClient, error)
	WaitMessage(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (MessageService_WaitMessageClient, error)
}

type messageServiceClient struct {
	cc *grpc.ClientConn
}

func NewMessageServiceClient(cc *grpc.ClientConn) MessageServiceClient {
	return &messageServiceClient{cc}
}

func (c *messageServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*LoginResult, error) {
	out := new(LoginResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/Login", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) Logout(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/mark2.MessageService/Logout", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetUserInfoList(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserInfoListResult, error) {
	out := new(UserInfoListResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/GetUserInfoList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetRoomInfoList(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*RoomInfoListResult, error) {
	out := new(RoomInfoListResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/GetRoomInfoList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetOwnUserInfo(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*UserInfoResult, error) {
	out := new(UserInfoResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/GetOwnUserInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) GetOwnRoomInfo(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*RoomInfoResult, error) {
	out := new(RoomInfoResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/GetOwnRoomInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) CreateRoom(ctx context.Context, in *CreateRoomRequest, opts ...grpc.CallOption) (*RoomInfoResult, error) {
	out := new(RoomInfoResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/CreateRoom", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) JoinRoom(ctx context.Context, in *JoinRoomRequest, opts ...grpc.CallOption) (*RoomInfoResult, error) {
	out := new(RoomInfoResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/JoinRoom", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) MatchRandom(ctx context.Context, in *MatchRequest, opts ...grpc.CallOption) (*RoomInfoResult, error) {
	out := new(RoomInfoResult)
	err := grpc.Invoke(ctx, "/mark2.MessageService/MatchRandom", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) ExitRoom(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/mark2.MessageService/ExitRoom", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) SendMessage(ctx context.Context, in *MessageRequest, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/mark2.MessageService/SendMessage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *messageServiceClient) SendStream(ctx context.Context, opts ...grpc.CallOption) (MessageService_SendStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MessageService_serviceDesc.Streams[0], c.cc, "/mark2.MessageService/SendStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &messageServiceSendStreamClient{stream}
	return x, nil
}

type MessageService_SendStreamClient interface {
	Send(*MessageRequest) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type messageServiceSendStreamClient struct {
	grpc.ClientStream
}

func (x *messageServiceSendStreamClient) Send(m *MessageRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *messageServiceSendStreamClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *messageServiceClient) WaitMessage(ctx context.Context, in *AccessToken, opts ...grpc.CallOption) (MessageService_WaitMessageClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MessageService_serviceDesc.Streams[1], c.cc, "/mark2.MessageService/WaitMessage", opts...)
	if err != nil {
		return nil, err
	}
	x := &messageServiceWaitMessageClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type MessageService_WaitMessageClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type messageServiceWaitMessageClient struct {
	grpc.ClientStream
}

func (x *messageServiceWaitMessageClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MessageService service

type MessageServiceServer interface {
	Login(context.Context, *LoginRequest) (*LoginResult, error)
	Logout(context.Context, *AccessToken) (*Result, error)
	GetUserInfoList(context.Context, *AccessToken) (*UserInfoListResult, error)
	GetRoomInfoList(context.Context, *AccessToken) (*RoomInfoListResult, error)
	GetOwnUserInfo(context.Context, *AccessToken) (*UserInfoResult, error)
	GetOwnRoomInfo(context.Context, *AccessToken) (*RoomInfoResult, error)
	CreateRoom(context.Context, *CreateRoomRequest) (*RoomInfoResult, error)
	JoinRoom(context.Context, *JoinRoomRequest) (*RoomInfoResult, error)
	MatchRandom(context.Context, *MatchRequest) (*RoomInfoResult, error)
	ExitRoom(context.Context, *AccessToken) (*Result, error)
	SendMessage(context.Context, *MessageRequest) (*Result, error)
	SendStream(MessageService_SendStreamServer) error
	WaitMessage(*AccessToken, MessageService_WaitMessageServer) error
}

func RegisterMessageServiceServer(s *grpc.Server, srv MessageServiceServer) {
	s.RegisterService(&_MessageService_serviceDesc, srv)
}

func _MessageService_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Login(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).Logout(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetUserInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetUserInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/GetUserInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetUserInfoList(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetRoomInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetRoomInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/GetRoomInfoList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetRoomInfoList(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetOwnUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetOwnUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/GetOwnUserInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetOwnUserInfo(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_GetOwnRoomInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).GetOwnRoomInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/GetOwnRoomInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).GetOwnRoomInfo(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_CreateRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).CreateRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/CreateRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).CreateRoom(ctx, req.(*CreateRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_JoinRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinRoomRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).JoinRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/JoinRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).JoinRoom(ctx, req.(*JoinRoomRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_MatchRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).MatchRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/MatchRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).MatchRandom(ctx, req.(*MatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_ExitRoom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccessToken)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).ExitRoom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/ExitRoom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).ExitRoom(ctx, req.(*AccessToken))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MessageServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mark2.MessageService/SendMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MessageServiceServer).SendMessage(ctx, req.(*MessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MessageService_SendStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MessageServiceServer).SendStream(&messageServiceSendStreamServer{stream})
}

type MessageService_SendStreamServer interface {
	Send(*Result) error
	Recv() (*MessageRequest, error)
	grpc.ServerStream
}

type messageServiceSendStreamServer struct {
	grpc.ServerStream
}

func (x *messageServiceSendStreamServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *messageServiceSendStreamServer) Recv() (*MessageRequest, error) {
	m := new(MessageRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _MessageService_WaitMessage_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AccessToken)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MessageServiceServer).WaitMessage(m, &messageServiceWaitMessageServer{stream})
}

type MessageService_WaitMessageServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type messageServiceWaitMessageServer struct {
	grpc.ServerStream
}

func (x *messageServiceWaitMessageServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

var _MessageService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mark2.MessageService",
	HandlerType: (*MessageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Login",
			Handler:    _MessageService_Login_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _MessageService_Logout_Handler,
		},
		{
			MethodName: "GetUserInfoList",
			Handler:    _MessageService_GetUserInfoList_Handler,
		},
		{
			MethodName: "GetRoomInfoList",
			Handler:    _MessageService_GetRoomInfoList_Handler,
		},
		{
			MethodName: "GetOwnUserInfo",
			Handler:    _MessageService_GetOwnUserInfo_Handler,
		},
		{
			MethodName: "GetOwnRoomInfo",
			Handler:    _MessageService_GetOwnRoomInfo_Handler,
		},
		{
			MethodName: "CreateRoom",
			Handler:    _MessageService_CreateRoom_Handler,
		},
		{
			MethodName: "JoinRoom",
			Handler:    _MessageService_JoinRoom_Handler,
		},
		{
			MethodName: "MatchRandom",
			Handler:    _MessageService_MatchRandom_Handler,
		},
		{
			MethodName: "ExitRoom",
			Handler:    _MessageService_ExitRoom_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _MessageService_SendMessage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendStream",
			Handler:       _MessageService_SendStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "WaitMessage",
			Handler:       _MessageService_WaitMessage_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mark2.proto",
}

func init() { proto.RegisterFile("mark2.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 908 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x7f, 0x6f, 0xdb, 0x44,
	0x18, 0xae, 0xed, 0x26, 0x71, 0x5e, 0x27, 0xae, 0x77, 0x30, 0xc8, 0x2a, 0x4d, 0x8a, 0x3c, 0x81,
	0x42, 0x81, 0xa9, 0xa4, 0x02, 0xa9, 0x42, 0x48, 0x2b, 0x5d, 0x54, 0xd2, 0xa5, 0x31, 0xba, 0x04,
	0x4d, 0xfc, 0x15, 0x8c, 0x7d, 0x0d, 0x56, 0x16, 0x5f, 0x66, 0x9f, 0x07, 0x91, 0xe0, 0xab, 0xf0,
	0x25, 0xf9, 0x02, 0xe8, 0xce, 0x67, 0xc7, 0xf6, 0x92, 0xa8, 0xd9, 0x5f, 0xf1, 0x7b, 0x77, 0xef,
	0xf3, 0xbc, 0xcf, 0xdd, 0xfb, 0x23, 0x60, 0x2c, 0xdd, 0x68, 0xd1, 0x7f, 0xbe, 0x8a, 0x28, 0xa3,
	0xa8, 0x26, 0x0c, 0xfb, 0x19, 0x18, 0x57, 0x9e, 0x47, 0xe2, 0x78, 0x4a, 0x17, 0x24, 0x44, 0x1f,
	0x43, 0x8d, 0xf1, 0x8f, 0x8e, 0xd2, 0x55, 0x7a, 0x4d, 0x9c, 0x1a, 0xf6, 0x6f, 0xa0, 0xff, 0x12,
	0x93, 0x68, 0x18, 0xde, 0x53, 0xf4, 0x04, 0xf4, 0x79, 0x44, 0x93, 0xd5, 0x2c, 0xf0, 0xc5, 0xa1,
	0x36, 0x6e, 0x08, 0x7b, 0xe8, 0x23, 0x13, 0xd4, 0xc0, 0xef, 0xa8, 0x62, 0x51, 0x0d, 0x7c, 0xf4,
	0x05, 0xd4, 0x63, 0xe6, 0xb2, 0x24, 0xee, 0x68, 0x5d, 0xa5, 0x67, 0xf6, 0x1f, 0x3d, 0x4f, 0x03,
	0xe0, 0x58, 0x13, 0xb1, 0x81, 0xe5, 0x01, 0xfb, 0x02, 0x5a, 0x19, 0xc3, 0x28, 0x88, 0x19, 0x7a,
	0x06, 0xc7, 0x6f, 0x82, 0x98, 0x75, 0x94, 0xae, 0xd6, 0x33, 0xfa, 0x27, 0x05, 0x47, 0x7e, 0x04,
	0x8b, 0x4d, 0xfb, 0x5f, 0x05, 0x74, 0x4c, 0xe9, 0xf2, 0xd0, 0xb8, 0x4e, 0x41, 0xf7, 0xdc, 0x95,
	0xeb, 0x05, 0x6c, 0x2d, 0x22, 0x6b, 0xe3, 0xdc, 0x2e, 0xc4, 0x7c, 0x5c, 0x8a, 0x99, 0xf3, 0x94,
	0x63, 0x46, 0x5d, 0x68, 0x25, 0x31, 0x89, 0x66, 0x81, 0x3f, 0x13, 0xb1, 0xd6, 0xba, 0x5a, 0xaf,
	0x8d, 0x81, 0xaf, 0x0d, 0x7d, 0xae, 0x82, 0xab, 0xca, 0xe2, 0xdb, 0xa3, 0x2a, 0x3b, 0x22, 0x55,
	0xfd, 0x03, 0x8d, 0x3b, 0x12, 0xc7, 0xee, 0x9c, 0xc8, 0xc0, 0x95, 0x3c, 0xf0, 0xcf, 0xe1, 0x98,
	0xad, 0x57, 0x44, 0x48, 0x31, 0xfb, 0x48, 0xfa, 0xcb, 0xd3, 0xd3, 0xf5, 0x8a, 0x60, 0xb1, 0xcf,
	0x23, 0xbb, 0x8f, 0xe8, 0x72, 0x26, 0xc3, 0x93, 0x22, 0x81, 0xaf, 0x89, 0x2b, 0xf4, 0x51, 0x07,
	0x1a, 0x1e, 0x0d, 0x19, 0x09, 0x99, 0xd0, 0xd9, 0xc4, 0x99, 0x69, 0x7f, 0x03, 0x86, 0x04, 0x14,
	0x21, 0xdb, 0xa5, 0x90, 0xcd, 0x32, 0xa5, 0x8c, 0xf8, 0x27, 0x68, 0x8d, 0xe8, 0x3c, 0x08, 0x31,
	0x79, 0x9b, 0x90, 0x98, 0xed, 0x7b, 0x8a, 0xa7, 0x00, 0x49, 0x18, 0xbc, 0x4d, 0xc8, 0x6c, 0x41,
	0xd6, 0x42, 0x47, 0x13, 0x37, 0xd3, 0x95, 0x57, 0x64, 0x6d, 0xff, 0x0a, 0x8f, 0xae, 0x23, 0xe2,
	0x32, 0xc2, 0xef, 0x24, 0x83, 0xeb, 0x15, 0x73, 0xd2, 0xc8, 0x65, 0x17, 0xd2, 0x56, 0xe6, 0x69,
	0xe9, 0x61, 0xd5, 0xf2, 0xc3, 0xda, 0x53, 0x38, 0xb9, 0xa5, 0x41, 0xf8, 0x61, 0xc0, 0x9f, 0x42,
	0x23, 0xa2, 0x74, 0x39, 0xcb, 0xd3, 0xa8, 0xce, 0xcd, 0xa1, 0x6f, 0xdf, 0x42, 0xeb, 0xce, 0x65,
	0xde, 0x1f, 0x87, 0x43, 0x5a, 0xa0, 0x6d, 0xae, 0x80, 0x7f, 0xda, 0x7f, 0x83, 0x99, 0xdd, 0xeb,
	0xc1, 0x68, 0x0f, 0xcd, 0x8c, 0xc2, 0xbb, 0x6b, 0xe5, 0x77, 0xbf, 0x85, 0x3a, 0x26, 0x71, 0xf2,
	0x86, 0x71, 0x2c, 0x8f, 0xfa, 0x44, 0x90, 0x6e, 0xb0, 0xd2, 0xcd, 0x6b, 0xea, 0x93, 0x18, 0x8b,
	0x7d, 0x8e, 0xb5, 0x4c, 0x09, 0xa4, 0x8a, 0xcc, 0xb4, 0x17, 0x60, 0xc8, 0x84, 0x10, 0x80, 0x9f,
	0x41, 0x3d, 0x12, 0x5f, 0x52, 0x47, 0xbb, 0x04, 0x89, 0xe5, 0x26, 0xfa, 0x16, 0x5a, 0xae, 0x50,
	0x36, 0x4b, 0x45, 0xab, 0x3b, 0x45, 0x1b, 0xee, 0xc6, 0xb0, 0xdf, 0x01, 0x2a, 0xb6, 0x8e, 0xc3,
	0x38, 0x2f, 0xc1, 0x4c, 0x8b, 0x24, 0xbc, 0xa7, 0x69, 0x15, 0xa7, 0xac, 0x1f, 0x55, 0x3a, 0x8e,
	0x40, 0x16, 0xe5, 0x9e, 0x59, 0x9c, 0xb7, 0x58, 0xdc, 0x07, 0xf3, 0xa6, 0x09, 0xb5, 0x83, 0xb7,
	0x84, 0xdc, 0x8a, 0x0a, 0x96, 0x4d, 0xc0, 0xcc, 0xfb, 0xe0, 0x41, 0x9c, 0x5f, 0x41, 0x33, 0xd7,
	0x2a, 0xe9, 0xde, 0x6b, 0xac, 0x7a, 0x26, 0x91, 0xd3, 0xe4, 0x8d, 0xe9, 0x50, 0x9a, 0x5c, 0x5a,
	0x85, 0x26, 0x07, 0xd4, 0x33, 0x45, 0x67, 0x4f, 0xc1, 0x28, 0x64, 0x16, 0xaa, 0x83, 0x3a, 0xbe,
	0xb1, 0x8e, 0xf8, 0xaf, 0xf3, 0xca, 0x52, 0xce, 0x5e, 0x00, 0x6c, 0xa6, 0x05, 0x02, 0xa8, 0x8f,
	0xe8, 0x9c, 0x26, 0xcc, 0x3a, 0x42, 0x4d, 0xa8, 0x89, 0x1c, 0xb3, 0x14, 0xd4, 0x86, 0xe6, 0x6b,
	0x37, 0x60, 0xa2, 0x10, 0x2d, 0x15, 0xb5, 0x40, 0x17, 0x9f, 0x41, 0x38, 0xb7, 0xb4, 0x33, 0x1b,
	0x60, 0xd3, 0xbb, 0x39, 0xc2, 0xf5, 0xc8, 0x99, 0x0c, 0x5e, 0x5a, 0x47, 0x48, 0x87, 0x63, 0xe7,
	0xe7, 0xc1, 0xd8, 0x52, 0xce, 0x2e, 0xf3, 0x9e, 0xc7, 0x4b, 0x85, 0x6f, 0x8c, 0x9d, 0xf1, 0xc0,
	0x3a, 0x42, 0x0d, 0xd0, 0x9c, 0xd7, 0x63, 0x4b, 0xe1, 0x4b, 0xd8, 0x71, 0xee, 0x2c, 0x95, 0x93,
	0xfd, 0x88, 0x9d, 0xab, 0x97, 0xd7, 0x57, 0x93, 0xa9, 0xa5, 0xf5, 0xff, 0xab, 0xe5, 0x55, 0x3b,
	0x21, 0xd1, 0xbb, 0xc0, 0x23, 0xe8, 0x5c, 0x46, 0x86, 0xb2, 0xc7, 0x2c, 0x36, 0xc7, 0x53, 0x54,
	0x5e, 0x14, 0x57, 0xf6, 0x65, 0xa6, 0x0b, 0x6d, 0xc9, 0xf6, 0xd3, 0xf2, 0x3d, 0xa3, 0x17, 0x70,
	0x72, 0x43, 0x58, 0x69, 0x5a, 0x6e, 0xf3, 0x7a, 0xb2, 0x2d, 0x83, 0x8b, 0x08, 0xa5, 0xc9, 0xb4,
	0x0f, 0x61, 0x4b, 0x96, 0x7f, 0x0f, 0xe6, 0x0d, 0x61, 0xce, 0x9f, 0x61, 0xfe, 0xb7, 0x60, 0x1b,
	0xc0, 0xe3, 0x6a, 0x76, 0x55, 0x9c, 0xf3, 0xd9, 0xbd, 0xcf, 0xb9, 0x92, 0x84, 0x3f, 0x00, 0x6c,
	0x26, 0x04, 0xea, 0xc8, 0x43, 0xef, 0x0d, 0x8d, 0x5d, 0xee, 0x97, 0xa0, 0x67, 0x53, 0x00, 0x7d,
	0x22, 0x8f, 0x54, 0xc6, 0xc2, 0x6e, 0x57, 0x23, 0x6d, 0xf5, 0x6e, 0xe8, 0xd3, 0x65, 0xfe, 0xb8,
	0xc5, 0xf6, 0xbf, 0xcb, 0xf5, 0x6b, 0xd0, 0x07, 0x7f, 0x05, 0xe2, 0xc6, 0x1f, 0xf2, 0xc2, 0x17,
	0x60, 0x4c, 0x48, 0xe8, 0x67, 0xff, 0x02, 0x1e, 0x57, 0x86, 0xae, 0xe4, 0xaa, 0x38, 0x7d, 0x07,
	0xc0, 0x9d, 0x26, 0x2c, 0x22, 0xee, 0xf2, 0x61, 0x3e, 0x3d, 0xe5, 0x5c, 0xe1, 0x64, 0xa2, 0x78,
	0x24, 0xd9, 0xb6, 0xf0, 0x2a, 0x53, 0xff, 0x5c, 0xf9, 0xbd, 0x2e, 0xfe, 0x43, 0x5e, 0xfc, 0x1f,
	0x00, 0x00, 0xff, 0xff, 0x3f, 0xeb, 0x9b, 0x85, 0x52, 0x0a, 0x00, 0x00,
}
